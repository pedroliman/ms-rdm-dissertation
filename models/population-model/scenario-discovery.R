# Tentando fazer scenario discovery


assign("mordm.globals", new.env(), envir=parent.env(environment()))

assign("mordm.globals", new.env())


#' Creates a marking rule from PRIM boxes.
#' 
#' PRIM identifies one or more boxes.  This method converts from the PRIM box
#' representation to a marking.
#' 
#' @param box the box generated by \code{\link{analyze.prim}}
#' @param mean the mean of the box
#' @param mass the mass of the box
#' @export
mordm.mark.box <- function(box, mean, mass) {
  result <- mordm.mark.rule(function(x) {
    names <- colnames(box)
    all(sapply(1:length(names), function(i) x[names[i]] >= box[1,names[i]] & x[names[i]] <= box[2,names[i]]))
  })
  
  attr(result, "mean") <- mean
  attr(result, "mass") <- mass
  attr(result, "box") <- box
  return(result)
}

#' Creates a marking rule based on a function.
#' 
#' Markings allow the user to highlight specific subsets of the data set.  These
#' marked sets can subsequently be plotted or used in supported calculations.
#' 
#' @param condition a function of the form \code{f:x -> boolean}, where \code{x}
#'        is a single row from the data set, returning \code{TRUE} if the row is
#'        part of the marking
#' @export
mordm.mark.rule <- function(condition) {
  mark <- condition
  class(mark) <- "mark"
  return(mark)
}


#' Display plot of PRIM boxes.
#' 
#' Generates a plot showing the bounds of the PRIM boxes.  Currently only works
#' well with one or two PRIM boxes.
#' 
#' @param data the original data set
#' @param mark a list of the PRIM boxes to display
#' @param main the plot title
#' @param scale.width if \code{TRUE}, reduce the width of the bars as more PRIM
#'        boxes are displayed
#' @param bar.width the width of the bars
#' @param col vector of bar colors
#' @param names names of each PRIM box to display in the legend
#' @param legend if \code{TRUE}, renders a legend on the plot
#' @param defaults draw horizontal lines to show default values
#' @export
mordm.plot.box <- function(data, mark, main="PRIM Box", scale.width=TRUE, bar.width=3, col=NULL, names=NULL, legend=TRUE, defaults=NULL) {
  nvars <- attr(data, "nvars")
  bounds <- attr(data, "bounds")
  
  if (is.null(bounds)) {
    stop("Bounds must be defined for the dataset")
  }
  
  longcol <- par("fg")
  outcol <- "transparent"
  
  # reset plot settings
  if (exists("default.par", mordm.globals)) {
    par(get("default.par", mordm.globals))
  } else {
    assign("default.par", par(no.readonly=TRUE), mordm.globals)
  }
  
  if (legend) {
    layout(c(1,2), heights=c(7,1))
  }
  
  par(xpd=TRUE, mar=c(4.1, 2.1, 4.1, 2.1))
  
  # create the plot
  barplot(matrix(rep(1,3*nvars),ncol=nvars), add=FALSE, main=main, col="transparent", beside=TRUE, width=1, names.arg=rep("",nvars), axes=FALSE, space=c(0,3), border=c("transparent",longcol,"transparent"))
  
  if (!is.list(mark)) {
    mark = list(mark)
  }
  
  if (is.null(col)) {
    colors <- rainbow(length(mark), v=0.9)
  } else {
    colors <- col
  }
  
  for (i in 1:length(mark)) {
    # allow each mark to either be a single PRIM box or a group of boxes
    if (is.list(mark[[i]])) {
      mark.as.list <- unlist(mark[[i]])
    } else {
      mark.as.list <- list(mark[[i]])
    }
    
    # display each box in the group
    for (j in 1:length(mark.as.list)) {
      box <- attr(mark.as.list[[j]], "box")
      
      if (is.null(box)) {
        warning("Given mark was not generated by PRIM")
        next
      }
      
      # scale the box dimensions
      values <- sapply(1:nvars, function(i) (box[,i]-bounds[1,i]) / (bounds[2,i]-bounds[1,i]))
      
      # ensure the scaled values do not exceed the variable bounds (PRIM boxes can
      # extend outside the bounds)
      values[1,] <- sapply(1:nvars, function(i) max(values[1,i], 0))
      values[2,] <- sapply(1:nvars, function(i) min(values[2,i], 1))
      
      # create the matrix that is plotted, row1=outside, row2=inside, row3=outside
      mat <- rbind(values[1,], values[2,]-values[1,], 1-values[2,])
      colnames(mat) <- colnames(box)
      
      width <- ifelse(scale.width, bar.width/i, bar.width)
      spacer <- bar.width - width
      space <- append(1+spacer, rep(1+(4/3)*spacer, nvars-1))
      
      barplot(mat[,1:nvars],
              add=TRUE,
              col=c(outcol,colors[i],outcol),
              border=NA,
              names.arg=rep("",nvars),
              axes=FALSE,
              main="",
              width=width,
              space=space)
    }
  }
  
  axis(1,at = seq(4.5,by=6,length.out=nvars),labels=colnames(mat[,1:nvars]),las=1, line=2)
  text(seq(4.5,by=6,length.out=nvars), y=rep(1, nvars), pos=3, labels=sprintf("%g", bounds[2,]), cex=0.8)
  text(seq(4.5,by=6,length.out=nvars), y=rep(0, nvars), pos=1, labels=sprintf("%g", bounds[1,]), cex=0.8)
  
  if (!is.null(defaults)) {
    segments(seq(4.5,by=6,length.out=nvars)-1.5, (defaults-bounds[1,])/(bounds[2,]-bounds[1,]), seq(4.5,by=6,length.out=nvars)+1.45, (defaults-bounds[1,])/(bounds[2,]-bounds[1,]), lwd=3)
  }
  
  # create the legend
  if (legend) {
    par(mar=c(0,0,0,0))
    plot.new()
    
    if (is.null(names)) {
      names <- sprintf("Box %i", 1:length(mark))
    }
    
    legend("center",
           legend=names,
           fill=colors,
           bty="o",
           cex=1.0,
           horiz=TRUE,
           xjust=0.5)
  }
}




library(sdtoolkit)

dados_sd = dadosplot = dplyr::filter(dados_simulacao, Tempo == FINISH) 

write.csv(dados_sd, file = "dadossd.csv")

factors = dados_sd[,3:7]

response = dados_sd[,2]
# response = (dados_sd[,2] > 15000) * 1
thr = 15000
thr.type = 1

library(prim)

box = prim.box(x = factors, y = response, threshold = thr, threshold.type = thr.type)

marks <- lapply(1:box$num.hdr.class, function(i) {
  i <- eval(i)
  colnames(box$box[[i]]) <- colnames(factors)
  mordm.mark.box(box$box[[i]], box$y.fun[i], box$mass[i])
})

bounds = NULL

if (is.null(bounds)) {
  bounds <- apply(factors, 2, range)
}

dummy.data <- list()
attr(dummy.data, "nvars") <- ncol(factors)
attr(dummy.data, "bounds") <- bounds
mordm.plot.box(dummy.data, marks[[which.box]])

# compute density and coverage of the box
varargs <- list(...)

if (is.null(varargs$threshold.type) || varargs$threshold.type==0) {
  
} else if (varargs$threshold.type == -1) {
  threshold <- mean(response)
  total.interesting = sum(response <= threshold)
  
  captured.indices <- mordm.select.indices(factors, mordm.mark.union(marks))
  captured.interesting = sum(response[captured.indices] <= threshold)
  
  cat("Coverage: ")
  cat(captured.interesting / total.interesting)
  cat("\n")
  cat("Density: ")
  cat(captured.interesting / length(captured.indices))
  cat("\n")
} else {
  threshold <- mean(response)
  total.interesting = sum(response >= threshold)
  
  captured.indices <- mordm.select.indices(factors, mordm.mark.union(marks))
  captured.interesting = sum(response[captured.indices] >= threshold)
  
  cat("Coverage: ")
  cat(captured.interesting / total.interesting)
  cat("\n")
  cat("Density: ")
  cat(captured.interesting / length(captured.indices))
  cat("\n")
}